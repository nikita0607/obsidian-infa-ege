# Какие-нибудь подсказоньки
Если перебираешь пары, или тройки чисел, тогда вычитай из длинны списка на единицу меньше (то есть, если пара - вичитаем один, если тройка - два...)
```python
nums = [1, 2, 3, 4]

# Сумма пар чисел
for i in range(len(nums)-1):
	print(nums[i]+nums[i+1])
```
# Различные штуки
##### Синтаксические интересности
######     for-else и while-else.
Если в цикле используеться `break`, то после цикла можно поставить блок
`else`, который сработает, если цикл завершился ==не== через `break`:

```python
for i in range(1, 9):
	if i == 10:
		break
else:
	print("break так и не выполнился!")
```

##### Операторы в python
```python
a = 1
b = 2

a + b # =3 Сложение
a - b # =-1 Разность
a * b # =2 Умножение
a / b # =0.5 Деление
a // b # =0 Целочисленное деление
a % b # =1 Остаток от деления

# Оператроры, работающие с двоичными представлениями чисел
# Двоичные представления чисел
# a = 01
# b = 10

# Поразрядная конъюнкция (поразрядное умножение)
# 01 & 10 == 00
a & b # =0

# Поразрядная дизъюнкция (поразрядное `сложение`)
# 01 | 10 == 11
a | b # =3

# Поразрядное исключающее ИЛИ (xor)
# 01 ^ 10 == 11
# Больше примеров
# 01 ^ 01 == 00
# 10 ^ 01 == 11
# 101 ^ 011 == 110
a ^ b # =3

```
##### Булевы операторы
```python
a = True
b = False

a or b # =True Логическое ИЛИ (логическое сложение)
a and b # =False Логическое И (логическое умножение)
not a # =False Логическое НЕ (отрицание)

"""
Не забывайте тот факт, что `True` и `False` - это тоже числа
поэтому к ним применимы операторы, работающие с обычными числами

True - это `1`
False - это `0`

(в примерах ниже используется сумма и 
исключающее ИЛИ для булевых значений)
"""
```
##### Логические упрощения
Если необходимо, чтобы выполнялось только ОДНО условие из ДВУХ
```python
a = 10
b = 12
cond_1 = a < 12 # =True
cond_2 = b < 12 # =False

# Вспоминаем, что True и False - тоже числа
# и потому мы можем их складывать
if (cond_1 + cond_2) == 1:
	print("Это работает так!")

if cond_1 ^ cond_2:
	print("И так тоже!")
```

Если есть сразу несколько условий, которые соединяться `or` или `and`, то можно использовать встроенные в python функции  `any` и  `all`

```python
#eq (1 == 2) or (2 == 2) or (3 == 1)
any((1 == 2, 2 == 2, 3 == 1)) 

#eq (1 == 2) and (2 == 2) and (3 == 1)
all((1 == 2, 2 == 2, 3 == 1)) 
```



##### Другие встроенные функции
```python
abs(num)  # модуль числа

# Функция ко всем элементам списка
# Возвращает нову
map(int, ["1", "2", "3"])

set("122") # Или set(['1', '2', '2']) == {'1', '2'}
# Преобразует последовательность в последовательность без повторов
# !! нет гарантий, что сохраняет порядок исходной строки !!
# Можно преобразовать в список с помощью `list()`

list(map(int, '123')) # == [1, 2, 3]
# Принимает на вход любую последовательность (даже строки)
# Возвращает `список`

# Хотя бы одно истина
any([True, False, False]) #== True
# Все истины
all([True, False, False]) #== False
```

##### Встроенный перевод числа в систему счисления
```python
n = 10
bn = bin(a)[2:]  # Двоичная система
on = oct(a)[2:]  # Восьмиричная система
hn = hex(a)[2:]  # Шестнадцатиричная система

# Все эти функции возвращают строки
```

##### Перевод числа в любую систему
```python
def to_osn(num, osn):
	"""
	Имя функции может быть любым
	Вместо функции можно писать сразу в коде

	num: число в десятичной системе
	osn: основание новой системы
	
	"""

	# От сюда

	res = ""

	while num > 0:
		res = str(num%osn) + res
		num //= osn
	# И до сюда код можно вставить в программу без функции
	
	return res
```

Перевод числа в СС с основанием больше 10
```python
def to_osn(num, osn):
	res = ""
	alph = '0123456789ABCDEFGHIJKLMOPQRSTUVWXYZ'

	while num > 0:
		res = alph[num%osn] + res
		num //= osn

	return osn
```


##### Перевод числа из любой системы в десятичную
```python
bn = '1111'
on = '17'
hn = 'F'

n = int(bn, 2)
n = int(on, 8)
n = int(hn, 16)

# int(число; основание системы, из которой переводится)
# но это работает только с основаниями больше 1 и меньше 37
```


##### Определение четности числа
```python
n = 2

if n%2 == 0:
	print("Четное")
if n%2 != 0:  # Или n%2 == 1
	print("Нечетное")
```

##### Первые и последние цифры числа
```python
num = 123

# Срезы
if str(num)[-2:] == '23':
	print("Это работает")

# Остаток от деления
if num%100 == 23:
	print("Это тоже")
```
==Осторожно!!==
Для отрицательных чисел, при использовании остатка от деления необходимо брать модуль, иначе это не сработает!
```python
num = -123

if str(num)[-2:] == '23':
	print("Это работает!")

if num%100 == 23:
	print("А это нет!!")

# но
if abs(num%100) == 23:
	print("Работает!")
```
##### Сумма цифр числа
```python
n = 123
s = sum(map(int, str(n))) # 6

n = bin(2)[2:]  # 10
s = sum(map(int, n))  # Сумма цифр в двоичной записи
# Также является суммой всех единиц двоичного числа
```


##### Работа со строками и символами
```python
s = '12345'
print(ord(s[0])) # Номер символа `1` в таблице ASCII

#################

num = 10
s1 = "val:" + str(num)
s2 = f"val:{num}" # f-строки

if s1 == s2:
	print("Они одиноковы!")
	
##################

s = 'C'

if s == 'A' or s == 'B' or s == 'C':
	print("Это, конечно, работает...")
if s in 'ABC':
	print("Но это выглядит проще")

##################
```

Что бы проверить, что символы в строке не повторяются:
```python
s = '123'


# Первый способ
syms = []
for sym in s:
	if sym in syms:
		break
	syms.append(sym)
else: # Об этом можно почитать в части про for-else выше
	print("В строке нет повторов!")

# А также можно покороче
if len(set(s)) == len(s):
	print("В строке все еще нет повторов!")
```

##### Однострочники
Ввод чисел из файла в одну строку
```python
file = open('file.txt')
nums = list(map(int, file.readlines()))
```
Применение своей функции ко всем элементам списка
```python
def f(x):
	return x+1

nums = [1, 2, 3]
nums = list(map(f, nums))

# nums = [2, 3, 4]
```






##### Маска
```python
from fnmatch import *

num = 12345
fnmatch(str(num), "1*4?")
```

##### Перебор последовательностей
```python
from itertools import *

"""
product(list, repeat=1)
возвращает все возможные комбинации 
букв из алфавита `list` длинной `repeat`
"""
for i in product("КОП", repeat=2):
	print(i)
	# ('К', 'К')
	# ('К', 'О')
	# ('К', 'П')
	# ('O', 'O')
	# ...

"""
permutations(list, len)
возвращает все перестановки символов из
алфавита `list` длинной `len`
"""
for i in permutations("КОП", 2):
	print(i)
	# ('К', 'О')
	# ('К', 'П')
	# ('О', 'К')
```


# Задача 2
## Сопоставление логических таблиц
==Внимание!==
Не забываем расставлять приоритеты операций (если вы их не помните, приоритеты
расписаны в КИМе)

###### №3650
![[Pasted image 20230203102843.png]]

Решение этой задачи на языкe Python:

```python
print("a b c") # Перечислить все буквы из задачи

for a in (0, 1):
	for b in (0, 1):
		for c in (0, 1):  # Создаем цикл для каждый буквы
		# Если значение F в задаче равно 0, то все условие оборачивается в not()
			if (a == b) or (c == b):  
				print(a, b, c)
							
```
`Ответ`: cab
получается после анализа полученной таблицы и сравнения с исходной

# Задача 5
##  Moments
##### Условие на `минимальное R > КАКОГО-ТО ЧИСЛА`  
Если в конце условия задачи говориться, что нужно, например: `наименьше R, больше 34`,
а в самой задаче есть условия, из-за которых число может строиться по разным алгоритмам, например: 
`а) Если число четное, дописать ноль справа б) Если число нечетное, дописать еденицу слева`
не следует решать эту задачу в лоб, можно поступать следующим образом:
Перебирать n, до момента, когда все результаты работы программы буду превышать условие на R
Затем найти наименьшее число из вывода, удовлетворяющее условию >34
Затем наложить еще одно условие на R, при котором он должен быть <= полученого числа

Пример кода:
```python
def to_r(n):
	r = ...
	# Какой-то алгоритм преобразования в R
	return r

for n in range(1000):
	r = to_r(n)

	if r > 34:
		print(r, n)
```
Вывод программы:
```
37 29
39 30
40 31
44 32
36 33
48 34
49 35
51 36
35 37
...
...
...
еще много-много строк
```
В начале вывода мы видим `37`. Её и возьмем для доп. условия

Измененный код:
```python
for n in range(1000):
	r = to_r(n)

	if r > 34 and r <= 37: # Вот тут меняем
		print(r, n)
```

Новый вывод:
```
37 29
36 33
35 37
```

И тут мы выбираем самое маленькое `R`. А значит ответ:
`N=37`

## Основные функции
##### Перевод числа в систему счисления
```python
n = 10
bn = bin(a)[2:]  # Двоичная система
on = oct(a)[2:]  # Восьмиричная система
hn = hex(a)[2:]  # Шестнадцатиричная система

```

##### Сумма цифр числа
```python
n = 123
s = sum(map(int, str(n))) # 6

n = bin(2)[2:]  # 10
s = sum(map(int, n))  # Сумма цифр в двоичной записи
# Также является суммой всех единиц двоичного числа
```

## Автомат для работы с числами
##### Задачечки
###### №4444
![[Pasted image 20230203103232.png]]

Рассмотрим решение на `Python`

```python
# 1000 - это случайное число, после которого алгоритм вытаст число точно
# превосходящее 126

ans = []
for n in range(1, 1000):  
	r = bin(n)[2:] # В двоичную

	if n%2 == 1:  # Выполняем второй этап из задачи
		r = '1' + r + '0'
	else:
		r = '11' + r + '11'

	r = int(r, 2)  # В десятичную систему

	if r < 126:
		ans.append(r)

print(max(r))

```
`Ответ:` 123
###### №4808
![[Pasted image 20230203104850.png]]

Рассмотрим и эту задачу:
```python
for n in range(1, 10000000):  # Ответ ооочень больщой
    s1 = 0

    for d in str(n):  # Вычисляем сумму цифр из первого этапа
        if int(d) % 2 == 0:
            s1 += int(d)

    s2 = 0

    string = str(n)  # Избавимся от лишних дальнейших преобразований в строку
    for i in range(len(string)):
        if (i + 1) % 2 == 0:
            s2 += int(string[i])

    r = abs(s1 - s2)
    if r == 29:
        print(n)
        break
```
`Ответ:` 6080818
###### №5901
Рассмотрим задачу послежнее
![[Pasted image 20230204003615.png]]

```python

"""
Пояснение:

Мы начинаем с числа 8, потому что от нас требуют
брять ТРИ последних разряда, а первое число с КАК МИНИМУМ тремя разрядами - 
это 8

"""

ans = []
for n in range(8, 10000):
	bn = bin(n)[2:]
	_n = n-bn.count('0') #  Вычитаем количество нулей

	bn = bin(_n)[2:]  # Получаем новую двоичную запись числа

	bn = bn[-3:] + bn

	if int(bn, 2) > 224:
		ans.append(int(bn, 2))

print(min(ans))
```
`Ответ:` 227


## Автомат с битами чётности

Задача номер один
###### №7
![[Pasted image 20230204005306.png]]

```python
for n in range(1, 10000):
	bn = bin(n)[2:]

	s = sum(map(int, bn))
	bn += str(s%2)

	s = sum(map(int, bn))
	bn += str(s%2)

	r = int(bn, 2)

	if r > 125:
		print(n)
		break
```
`Ответ:` 31

Следущая задача
###### №3523
![[Pasted image 20230204005857.png]]

```python
'''


'''
ans = []
for n in range(1, 10000):
	_n = n*10 + n%10  # Дописываем в конец последнюю цифру
	bn = bin(_n)[2:]

	if sum(map(int, bn))%2 == 1:
		bn += '1'
	else:
		bn += '0'

	if int(bn, 2) > 413:
		ans.append(n)

print(min(ans))
```
`Ответ:` 21



## Автомат с инверсией битовой записи
##### Задачи:
###### №1747
![[Pasted image 20230204010719.png]]

```python
for n in range(1, 256):
	bn = bin(n)[2:]

	# Чтобы число было восьмибитным, дописываем 
	# недостающие нули в начало числа
	bn = '0'*(8-len(bn)) + bn
	bn2 = ''

	repl = False
	for i in range(7, -1, -1):
		if repl:
			if bn[i] == '1':
				bn2 = '0' + bn2
			else:
				bn2 = '1' + bn2
		else:
			bn2 = bn[i] + bn2
			
		if bn[i] == '1':
			repl = True

	r = int(bn2, 2)

	if r == 98:
		print(n)
		break
```
`Ответ:` 128

###### №3525
![[Pasted image 20230204011739.png]]

```python
for n in range(1, 10000):
	dd = ""

	for i in str(n):
		bn = bin(int(i))[2:]
		bn = '0'*(4-len(bn)) + bn

		dd += bn

	bn = ''
	for i in dd:
		if i == '0':
			bn += '1'
		else:
			bn += '0'

	if int(bn, 2) == 151:
		print(n)
		break
```
`Ответ: 68

# Задача 6+
Для решения этой задачи используется модуль `turtle`
## Интересные вещи
##### +Программа для автоматического подсчета точек:
==Внимание==
КОД ИЗ ЗАДАЧИ должен быть строго замкунтой фигурой, иначе программа можеть давать неверный результат, т.е. нужно прекратить работу КОДА ИЗ ЗАДАЧИ как только исполнитель замкнет фигуру (то есть убрать лишние итерации цикла)
###### Пример: 
```python
from turtle import *

for i in range(10):
	forward(3)
	right(60)
#   |    Оптимизируем
#  \ /
for i in range(3):
	forward(3)
	right(60)
```
###### Код для подсчета точек:
```python
from turtle import *


color("black", "red") # Устанавливаем цвета
speed(1000)
 
m = 100  # Масштаб рисунка

begin_fill()
# КОД ИЗ ЗАДАЧИ
end_fill()

# Секретный магический код
canvas = getcanvas()
count = 0

for x in range(-100*m, 100*m, m):
	for y in range(-100*m, 100*m, m):
		item = canvas.find_overlaping(x, y, x, y)
		
		# item[0] == 5 проверяет,
		# с чем произошло пересечение
		if len(item) == 1 and item[0] == 5: # Проверяем, были ли пересечения
			count += 1

			### Для проверки можно расставить эти точки ###
			goto (x,y)
			dot(5,'blue')
			###############################################

print(count)
done()
```
##### Математические решения
Каноническое уравнение прямой*$$\frac{y-y_1}{y_2-y_1} = \frac{x-x_1}{x_2-x_1}$$
 

## Основные моменты

Если в задаче дан исполнитель `Чертежник`, командой перемещения которого является `сместиться`, то используется такой код для смещения:
```python
from turtle import *

m = 10 # Задаем масштаб

for i in range(2):
	goto(ycord(), xcord()-12*m) # сместиться на (0, -12)
	goto(ycord()+10*m, xcord()+12*m) # сместиться на (10, 12)
```

# Задача 8
##### Задачи на комбинаторику
## Анализ списка слов заданной длинны
Как по мне, самый простой тип этой задачи

==Не забывайте==
Номер числа будет на единицу больше его значения!

##### Итак, задачи:
###### №5086
___
(Досрочный ЕГЭ-2022) Все 5-буквенные слова, составленные из букв слова ПАРУС записаны в алфавитном порядке и пронумерованы. Вот начало списка:  

1. ААААА  
2. ААААП  
3. ААААР  
4. ААААС  
5. ААААУ  
6. АААПА  
...  

Укажите номер первого слова в списке, начинающегося на У, в котором две буквы А не стоят рядом?
___

Для начала, расставим заданные буквы в алфивитном порядке и присвоим им номера, начиная с нуля
А-0, П-1, Р-2, С-3, У-4
И теперь, если обратить внимание, мы получили пятиричную систему счисления!
Только в ней все числа записаны 5 цыфрами с ведущими нулями, то есть:
``` shell
'ААААА' = 00000
'ААААП' = 00001
'ААААР' = 00002
...
```

Теперь составим слово по условию так, что бы его чтсловое представление было наименьшим

```shell
'УАПАП' = 40101 в пятиричной системе
```

Теперь переведем в десятичную:
```shell
40101 = 4*5^4 + 5^2 + 1 = 2500 + 25 + 1 = 2526
```
А теперь обратим внимание, что `первое` число равно `нулю`
Значит `2526` соответствует `2527` число

`Ответ:` 2527



## Сколько слов можно составить при заданных ограничениях?

##### Помощнички
В Python встроенна библиотека, под названием `itertools`

Она содержит несколько полезных функций:
```python
from itertools import *

# Все возможные последовательности длинно=`repeat`из заданных
# символов
product("abc", repeat=10)

# Все возможные комбинации из символов с заданной длинной,
# (не больше, чем кол-во символов)
combinations("abc", 2)

# Все перестановки символов с заданной длинной,
# (не больше, чем кол-во символов)
permutations("abc", 3)
```

##### Задачечки
Задача эта на прямое использавние комбинаторики
В зависимости от сложности может решаться как вручную, так и программой

Задача
###### №5889
___
(А. Бриккер) Миша составляет пятибуквенные слова из букв К, О, Н, Ф, Е, Т, А. Он выбирает слова, которые содержат не менее двух гласных, причём между любыми двумя гласными есть хотя бы одна согласная. Сколько различных слов может составить Миша?
___

Решим сначала ручками:

Всего букв: 7
Гласных букв: 3
Согласных: 4

Рассмотрим все возможные варианты
г - гласная, с - согласнаяг 
1) с г с с
2) г с с г с
3) г с с с г
4) с г с г с
5) с г с с г
6) с с г с г
||
== > 3 * 3 * 4 * 4 * 4 * `6` (кол-во вариантов с двумя гласными)

г с г с г => 3 * 3 * 3 * 4 * 4 (с тремя гласными)

И, если все сложить, получим: 3888

А теперь программа
```python
from itertools import product

words = product('конфета', repeat=5)
count = 0
for w in words:
	if w.count('о') + w.count('е') + w.count('а') < 2:
		continue
	for i in range(len(w)-1):
		if w[i] in 'аое' and w[i+1] in 'аое':
			break
	else:
		count += 1

print(count)
```
`Ответ:` 3888



## Сколько чисел можно составить при заданных ограничениях?
Так же может решаться ручками и программно

Решая программой, главное уметь работать со строками, переводить в системы счисления и просто думать

##### Решаем!

###### №1894
![](Pasted%20image%2020230302234219.png)
Решение на питончике

Начнем с решения объемнее, но без использования дополнительных конструкций
```python
count = 0

for n in range(100000, 1000000, 5):
    sn = str(n)
    nums = []

    flag = True

    for s in sn:
        if s in nums:
            flag = False
            break
        else:
            nums.append(s)
    if not flag:
        continue

    for i in range(len(sn) - 1):
        if int(sn[i]) % 2 == int(sn[i + 1]) % 2:
            flag = False
            break
    if flag:
        count += 1

print(count)
```
А теперь используем более сложные конструкции
```python
count = 0

for n in range(100000, 1000000, 5):
	sn = str(n)
	if len(set(sn)) == len(sn):
		for i in range(len(sn)-1):
			if int(sn[i])%2 == int(sn[i+1])%2:
				break
		else:
			count += 1
			
print(count)
```

`Ответ:` 1296


# Задача 14
## Основные функции
Перевод в любую систему счисления
Перевод из любой систеы счисления в десятичную
## Задачи
efefefefef (уауауауа)
###### №5471
___
(Е. Джобс) Значение выражения $$7*729^{543} - 6*81^{765} - 5*9^{987} - 20  $$записали в системе счисления с основанием 9. Определите количество цифр 8 в записи этого числа.
___

Решааем
```python
val = 7*(729**543) - 6*(81**765) - 5*(9**987) - 20
res = ''

while val > 0:
	res = str(val%9) + res
	val //= 9

print(res.count('8'))
```
`Ответ:` 1625


###### №5483
___
(Демо-2023) Операнды арифметического выражения записаны в системе счисления  
с основанием 15:  
$$ 123x5_{15} + 1x233_{15} $$
В записи чисел переменной x обозначена неизвестная цифра из алфавита 15-ричной системы счисления. Определите наименьшее значение x, при котором значение данного арифметического выражения кратно 14. Для найденного значения x вычислите частное от деления значения арифметического выражения на 14 и укажите его в ответе в десятичной системе счисления. Основание системы счисления в ответе указывать не нужно.
___


Обращаем внимание, что нам нужен ==наименьший x==
Значит первый попавшийся подходящий x и будет ответом

Задача явно говорит, что  x - пятнидцатиричная цифра
славно, решаем!

```python
for x in range(15):
	# Переводим числа в десятичную систему счисления
	n1 = 5 + x*15 + 3*(15**2) + 2*(15**3) + 1*(15**4)
	n2 = 3 + 3*15 + 2*(15**2) + x*(15**3) + 1*(15**4)

	if (n1+n2)%14 == 0:
		print((n1+n2)//14)
		break  # Нашли, значит пора выйти из цикла
		
```
`Ответ:` 8767

###### № 5822
[НЕМНОГО ХАРДОВЕНЬКАЯ]
___
А. Богданов) Операнды арифметического выражения записаны в системе счисления с некоторым частично заданным основанием :  
$$ 23_{1x324} – 134x2_{22} $$
В записи чисел переменной x обозначена неизвестная цифра. Определите наибольшее значение x, при котором абсолютное значение данного арифметического выражения при делении на 50 даёт остаток 31. Для найденного значения x вычислите целое частное от деления абсолютного значения арифметического выражения на 50 и укажите его в ответе в десятичной системе счисления. Основание системы счисления в ответе указывать не нужно.
___

Итак, x - это цифра
Значит от 0 до 9 :3

Абсолютное значение - значит нужна функция `abs()`

```python
for x in range(10):
	osn = int('1' + str(x) + '324')
	
	n1 = 2*osn + 3  # Преобразуем число в дес. систему
	n2 = int('134' + str(x) + '2', 22)

	if abs(n1-n2)%50 == 31:
		print(abs(n1-n2)//50)
		# break отсутствует, потому что нам нужен максимальный x,
		# а значит, нужно идти до конца

		# хотя в этой задаче ответ выводится всего один
```

Немного упрощеный код с использованием f-строк
```python
for x in range(10):
	osn = int(f"1{x}324")
	
	n1 = 2*osn + 3  # Преобразуем число в дес. систему
	n2 = int(f"134{x}2", 22)

	if abs(n1-n2)%50 == 31:
		print(abs(n1-n2)//50)
		# break отсутствует, потому что нам нужен максимальный x,
		# а значит, нужно идти до конца

		# хотя в этой задаче ответ выводится всего один

```
`Ответ:` 4870

###### №4416
___
(П. Волгин) Значение выражения: $$ 16^{44}*16^{30} - (32^5 * (8^{40} - 8^{32}) * (16^{17} – 32^4)) $$записали в системе счисления с основанием 16. Затем в шестнадцатеричной записи этого числа все цифры E заменили на 1, а цифру в разряде 4 удалили. Найдите количество единиц в шестнадцатеричной записи числа после изменения. Ответ запишите в десятичной системе счисления.
___

Сдандартное решение #1
```python
def to_osn(num, osn):
    res = ""
    alph = "0123456789ABCDEFGHIJKLMOPQRSTUVWXYZ"

    while num > 0:
        res = alph[num % osn] + res
        num //= osn

    return res


# Считаем число
val = 16**44 * 16**30 - (32**5 * (8**40 - 8**32) * (16**17 - 32**4))
# Заменяем `E` на 1
res = to_osn(val, 16).replace("E", "1")
# Удаляем 4 разряд из числа
res = res[:-5] + res[-4:]

print(res.count("1"))
```
Решение #2
```python
num = 16**44 * 16**30 - (32**5 * (8**40 - 8**32) * (16**17 - 32**4))
count = 0

r = 0

while num > 0:
	# Проверяем, что число цифра ИЛИ =1 ИЛИ  =`E`
	# а также пропускаем 4 разряд
    if (num % 16 == 1 or num % 16 == 14) and r != 4:
        count += 1
    num //= 16
    r += 1

print(count)
```
`Ответ:` 3

# Задача 17
## Основные функции
Чтение чисел из файла в одну строку
Сумма цифр числа
Выполнение только одного условия из двух
Цифры в начале и в конце

## Один проход

Задачечкиииууиуиуи
###### №4360
___
(П. Волгин) В файле [17-8.txt](https://kpolyakov.spb.ru/cms/files/ege-seq/17-8.txt) содержится последовательность целых чисел. Элементы последовательности могут принимать значения от 0 до 1000 включительно. Определите сначала количество пар элементов последовательности, в которых сумма цифр в двоичной записи хотя бы одного из чисел больше 5 и нечетна, а затем максимальную из сумм элементов таких пар. Под парой подразумевается два идущих подряд элемента последовательности.
___

Что нам тут нужно?
Для начала, считываем числа (и так во всех таких задачах)

Пары элементов - значит не забываем отнять в цикле единицу от длинны списка
Хотя бы одна - значит можно и два - значит  ==or==
Максимальную из сумм (значит изначально переменная max_s = 0)

```python
file = open("17-8.txt")
nums = list(map(int, file.readlines()))

max_s = 0
count = 0

for i in range(len(nums)-1): # <- Отнимаем единицу
	bn1 = bin(nums[i])[2:]
	bn2 = bin(nums[i+1])[2:]

	s1 = sum(map(int, bn1))
	s2 = sum(map(int, bn2))

	if (s1 > 5 and s1%2 == 1) or (s2 > 5 and s2%2 == 1):
		count += 1
		max_s = max(max_s, nums[i]+nums[i+1])

print(count, max_s)
```
`Ответ:` 25 1773

###### №4540
___
В файле [17-205.txt](https://kpolyakov.spb.ru/cms/files/ege-seq/17-205.txt) содержится последовательность целых чисел. Элементы последовательности могут принимать целые значения от –10 000 до 10 000 включительно. Определите количество пар, в которых хотя бы один из двух элементов делится на 7, а их сумма заканчивается на 19. В ответе запишите два числа: сначала количество найденных пар, а затем – максимальную сумму элементов таких пар. В данной задаче под парой подразумевается два идущих подряд элемента последовательности.
Сразу обращаем внимание, что числа могут быть ==отрицательными==
Это значит, что при операции остатка от деления нужно сначала взять модуль числа
___

Решим и её
```python
file = open("17-205.txt")
nums = list(map(int, file.readlines()))

count = 0
max_s = 0

for i in range(len(nums)-1):
	n1 = nums[i]
	n2 = nums[i+1]

	# Не забываем использовать модуль при остатке от деления
	# потому что у нас есть отрицательные числа
	
	if (abs(n1)%7 == 0) or (abs(n2)%7 == 0):
		if abs(n1+n2)%100 == 19:
			count += 1
			max_s = max(max_s, n1+n2)

print(count, max_s)
```
`Ответ:` 12 17219


###### №5437
==ХАРДВОВАЯ==
___
(Л. Малинов) В файле [17-343.txt](https://kpolyakov.spb.ru/cms/files/ege-seq/17-343.txt) содержится последовательность целых чисел. Элементы последовательности могут принимать целые значения от 0 до 10 000 включительно. Определите количество троек, в которых для каждого числа тройки сумма цифр в нечётных разрядах нацело делится на сумму цифр в чётных разрядах. Разряды нумеруются с нуля справа налево. В ответе запишите два числа: сначала количество найденных троек, а затем – минимальную сумму элементов таких троек. В данной задаче под тройкой подразумевается три идущих подряд элемента последовательности.
___

Решааем
```python
file = open('17-343.txt')
nums = list(map(int, file.readlines()))

count = 0
min_sum = 10**9

# Напишем функцию, которая обработает каждое число отдельно
def f(n):
	# Так как разряды нумеруются справа налево
	# развернем число, чтобы нумеровать слева направо
	sn = str(n)[::-1]

	s_chet = 0
	s_nechet = 0

	for i in range(1, len(sn), 2):
		s_nechet += int(sn[i])

	for i in rangr(0, len(sn), 2):
		s_chet += int(sn[i])

	return s_nechet%s_chet == 0

for i in range(len(nums)-2):
	if f(nums[i]) and f(nums[i+1]) and f(nums[i+1]):
		count += 1
		min_sum = min(min_sum, nums[i]+nums[i+1]+nums[i+2])

print(count, min_sum)
```
## Два+ прохода
Задачи:
###### №5164
___
В файле [17-298.txt](https://kpolyakov.spb.ru/cms/files/ege-seq/17-298.txt) содержится последовательность целых чисел. Элементы последовательности могут принимать целые значения от 0 до 10 000. Найдите все пары элементов последовательности, в которых ровно одно число больше одной из своих цифр в 197 раз, а сумма чисел пары меньше, чем максимальный элемент последовательности кратный 197. В ответе запишите количество найденных пар, затем максимальную из сумм элементов таких пар. В данной задаче под парой подразумевается два идущих подряд элемента последовательности.

Два прохода означает, что сначала мы находим одно число, заданное условием задачи
И только затем начинаем искать пары чисел
___

Решим её:
```python
file = open("17-298.txt")
nums = list(map(int, file.readlines()))

max_num = 0

# С заданными условиями, и учитывая то, что мы ищем одно число,
# нам не нужно перебирать все индексы списка `nums`
for n in nums:
    if n % 197 == 0:
        max_num = max(max_num, n)

count = 0
max_sum = 0


# Будем проверять каждое число с помощью функции
def check(n):
    for d in str(n):  # `d` - от слова  digit
        if d == "0": # На ноль делить нельзя
            continue
        if n // int(d) == 197 and n % int(d) == 0:
            return True
    return False


for i in range(len(nums) - 1):
    n1 = nums[i]
    n2 = nums[i + 1]

	#  Не забываем, как написать: ЕСЛИ ВЫПОЛНЯЕТСЯ ТОЛЬКО ОДНО ИЗ ДВУХ
	#             \/-----вот тут
    if (check(n1) + check(n2)) == 1 and n1 + n2 < max_num:
        count += 1
        max_sum = max(max_sum, n1 + n2)

print(count, max_sum)
```
`Ответ:` 4341 9452

###### №5260
==ХАРДОВАЯ==
___
(Е. Джобс) В файле [17-332.txt](https://kpolyakov.spb.ru/cms/files/ege-seq/17-332.txt) содержится последовательность целых чисел. Элементы последовательности – четырёхзначные натуральные числа. Найдите все тройки элементов последовательности, в которых первое и последнее число тройки имеют одинаковую сумму цифр, а среднее число тройки меньше, чем среднее арифметическое всех чисел в файле, кратных 17. В ответе запишите количество найденных троек, затем самую часто встречающуюся сумму разрядов среди средних чисел таких троек. В данной задаче под тройкой подразумевается три идущих подряд элемента последовательности.
___

Тройки чисел!
Как много условий, значит идем по порядку

```python
# Читаем числа
file = open("17-332.txt")
nums = list(map(int, file.readlines()))

# Начнем со среднего арифметического чисел, кратных 17

count = 0
s = 0

for n in nums:
    if n % 17 == 0:
        s += n
        count += 1

sr_arithm = s / count

# Обнулим `count`, чтобы потом записать в него ответ
count = 0
max_sum = 0
max_sum_count = 0

sums = []
set_sums = set() # Множество - добавляет значени только если его ещё нет

# Теперь примемся за перебор таких троек:
for i in range(len(nums) - 2):
    n1 = nums[i]
    n2 = nums[i + 1]
    n3 = nums[i + 2]

	# Считаем сумму цифр в числе
    s1 = sum(map(int, str(n1)))
    s2 = sum(map(int, str(n2)))
    s3 = sum(map(int, str(n3)))

    if s1 == s3 and n2 < sr_arithm:
        sums.append(s2) # Доюавляем очередную сумму в список
        set_sums.add(s2)  # И в множество
        count += 1

# А тут мы перебираем все наши суммы, которые храняться в единственном экземпляре
# и ищем ту, что встречается чаще
for n in set_sums:
    cur_sum_count = sums.count(n)
    if cur_sum_count > max_sum_count:
        max_sum_count = cur_sum_count
        max_sum = n

print(count, max_sum)
```
`Ответ:` 257 19
# Задача 18
Задачечка в excel! Юпиии

## Это база
Базовым для всех 18 задач является создание новой таблицы, в которой значения будут считаться динамически с помощью функций `МИН` и `МАКС`

Разберем простую задачу и маленькую табличку.

Пусть робот стоит в ==верхней левой== клетке таблицы. Он может двигаться только вправо и вниз. В каждой клетке лежат монеты, которые он забирает после посещения этой клетки. Какое максимальное количество монет может собрать робот?

Таблица0:

| 0 | A | B | C | D |
|---|---|---|---|---|
| 1 | ==24== | 12 | 100 | 29 |
| 2 | 19 | 10 | 15 | 10 |
| 3 | 32 | 15 | 20 | 7 |
| 4 | 12 | 23 | 18 | 6 |


А теперь напишем её решение
(`0` перед ссылкой на столбец означает, что значение береться из `Таблица0`)

| 0 | A | B | C | D |
|---|---|---|---|---|
| 1 | ==24== | =A1+0B1 | =B1+0С1 | =C1+0D1 |
| 2  | =A1+0А2 | =МИН(B1; A2)+0B2 <- растягиваем это формулу на все пустые ячейки| .. | .. |
| 3 | =A2+0A3 | .. | .. | .. |
| 4 | =A3+0A4 |..|..| .. (тут будет ответ, когда растянешь формулу) |

И мы получаем ответ в правой нижней клетке (куда шел робот)

Если нам нужно найти еще и максимум, то мы:
1) Выделяем нашу новую таблицу
2) Нажимаем заменить
3) Заменяем `МИН` на `МАКС`

##  Ямки
Для начала помечаем ямки в исходной таблице желтым цветом

Допустим, ямки - это отрицательные числа,  а робот начинает наверху слева:
Таб0
| 0 | A | B | C | D |
|---|---|---|---|---|
| 1 | 24 | ==-12== | 100 | 29 |
| 2 | 19 | 10 | 15 | 10 |
| 3 | ==-32== | 15 | ==-20== | 7 |
| 4 | 12 | 23 | 18 | 6 |

Тогда мы создаем новую таблицу как обычно, затем:
1) Копируем исходную таблицу с раскрашенными полями
2) Нажимаем на правый-верхний угол новой таблицы
3) Правая кнопка мыши - специальная вставка - вставить форматирование
4) Убираем все поля, которые раскрашенны цветом
| 0 | A | B | C | D |
|---|---|---|---|---|
| 1 | 24 |==--==| C1+0B1 | D1+0C1 |
| 2 | A1+0A2 | =МАКС(...) | =МАКС(...) | =МАКС(...) |
| 3 |==--==| =МАКС(...) |==--==| =МАКС(...) |
| 4 | A3+0A4 | =МАКС(...) | =МАКС(...) | =МАКС(...) |

Затем видим, что в клетки сверху, которые находятся справа от ямы, мы попасть больше не можем, значит их тоже надо удалить
| 0 | A | B | C | D |
|---|---|---|---|---|
| 1 | 24 |==--==| | |
| 2 | A1+0A2 | 10 | 15 | 10 |
| 3 |==--==| 15 |==--==| 7 |
| 4 | A3+0A4 | 23 | 18 | 6 |


А также клетки слева, которые под ямой
| 0 | A | B | C | D |
|---|---|---|---|---|
| 1 | 24 |==--==| | |
| 2 | A1+0A2 | =МАКС(...) | =МАКС(...) | =МАКС(...) |
| 3 |==--==| =МАКС(...) |==--==| =МАКС(...) |
| 4 | | =МАКС(...) | =МАКС(...) | =МАКС(...) (ответ)|


## Стенки как ямки
Решение ровно такое же, как и у ямок
## Стенки между клетками
#to-do
# Задача 19-21
Это задачи на теорию игр
##### Основные функции
```python
conds = [True, False, False]

# Применяет ИЛИ ко всем операндам из последовательности
any(conds) # == True

# Применяет И ко всем операндам из последовательности
all(conds) # == False
```

Основная функция для решения этих задач (две кучи)
```python
"""
Часть задачи:

Игра кончается, когда в кучах суммарно не менее 73 камней
Всего куч две

Своим ходом игрок может добавить один камень в кучу или увеличить количество камней в куче в два раза

В первой куче было 12 камней, а во второй S камней

Найдите такое наименьшее и натбольшее S, при котором Петя (первый игрок) 
победит ВТОРЫМ ХОДОМ при любом ходе Вани
"""


"""
Распишем ходы в игре

1 ход в игре совершает Петя
2 ход в игре - Вася
3 ход - Петя
4 - Вася...

То есть, второй ход Пети - это третий ход в игре
"""


# Задается условием задачи
# сколько камней должно быть в куче, чтобы игра закончилась
MAX_VAL = 73


def f(k1, k2, st, m):
	"""
	k1, k2 - кучи
	st - игровой ход
	m - ход, на котором ожидается конец игры
	"""

	# Если игрок победил
	if k1+k2 >= MAX_VAL:
		return st%2 == m%2 # Cовершил ли последний ход игрок, который нам нужен
	
	# Если сделано уже слишком много ходов
	if st == m:
		return 0
		
	st += 1
	# Просчитываем все возможные шаги
	moves = [f(k1+1, k2, st, m), f(k1*2, k2, st, m),
			 f(k1, k2+1, st, m), f(k1, k2*2, st, m)]

	# Если ход совершал игрок, который нам нужен
	if st%2 == m%2:
		return any(moves)
	return all(moves)


# Перебираем вторую кучку
for s in range(1, 61):
	# Перебираем кол-во максимальных ходов
	for m in range(1, 10):
		# Если игра закончилась первым ходом, то этот вариант нам не подходит
		if m == 1 and f(12, s, 0, m):
			break
		# А если третьим, то это наш ответ
		if m == 3 and f(12, s, 0, m):
			print(s)
```

Если в задаче сказанно, что соперник совершил `неудачный ход`,  то функция `all` меняется на `any`:

```python
def f(k1, k2, st, m):
	...
	if st%2 == m%2:
		return any(moves)
	return any(moves)
```


Если в задаче сказанно, что игрок может победить первым или вторым ходом, но не побеждает гарантированно первым, и требуется несколько ответов, то нужно проверить минимальные значения на предмет того, что в них игрок может победить первым ходом

Это можно сделать, поменяв ход соперника на неудачный и подставив числа из ответа.
И если в этих условиях он побеждает первым ходом, то ответ подходит.

Например, в задаче должен победить второй игрок и вывелся такой  ответ:
```shell
4
5
6
```

А нам нужны максимальный и минимальный
Тогда поменяем нашу функцию и проверим первый ответ

```python
def f(k1, k2, st, m):
	...
	return any(moves)

print(f(ЗНАЧЕНИЕ_ИЗ_ЗАДАЧИ, 4, 0, 2))
```
Вывод:
```python
False
```
Отсюда следует, что  `4` не пойдет в ответ


# Задача 24
## Основные функции
Получение номера сивола в таблице ASCII
```python
ord('A') # == 65
```
## Поиск максимума и минимума
Задачечулечки
###### №3347
___
(Е. Джобс) Текстовый файл [24-j2.txt](https://kpolyakov.spb.ru/cms/files/ege-sym/24-j2.txt) состоит не более чем из 106 символов F, A, I, L. Определите максимальное количество подряд идущих одинаковых букв.
___
Решааем
```python
file = open("24-j2.txt")
line = file.readline()

count = 1
max_count = 0

for i in range(len(line)-1):
	if line[i] == line[i+1]:
		count += 1
	else:
		max_count = max(max_count, count)
		count = 1

print(max_count)
```
`Ответ:` 75

###### №3348
___
(Е. Джобс) Текстовый файл [24-j1.txt](https://kpolyakov.spb.ru/cms/files/ege-sym/24-j1.txt) состоит не более чем из 106 кириллических символов К, О, Т. Определите максимальное количество подряд идущих комбинаций КОТ.
___
Нам нужны комбинации символов
Заметим, что комбинация `КОТ` не является самопересекающейся, т.е., конец одной комбинации не может являтся началом другой:
	\\/--конец первой
КОТКОТ
	  ^-- начало второй
Решааем путем замены всех комбинаций `КОТ` на один символ, например 1

```python
file = open("24-j1.txt")
line = file.readline()

line = line.replace("КОТ", '1')

count = 1
max_count = 0
for i in range(len(line)-1):
	if line[i] == '1' and line[i] == line[i+1]:
		count += 1
	else:
		max_count = max(max_count, count)
		count = 1

print(max_count)
```
`Ответ:` 75


Некст таск ==немного СЛОЖНЕНЬКАЯ==
№3349
![[Pasted image 20230210124417.png]]

Решаем
```python
file = open("24-1.txt")
line = file.readline()

# Начинаем со второго символа т.к. первый не является локальным минимумом
f_ind = 0
max_dist = 0

for i in range(1, len(line)-1):
	# Получаем ascii номера символов
	a1 = ord(line[i-1])
	a2 = ord(line[i])
	a3 = ord(line[i+1])

	if a2 < a3 and a2 < a1:
		if f_ind == 0: # Если еще не находили локальных минимумов
			f_ind = i
		else:
			distance = i-f_ind
			max_dist = max(max_dist, distance)
			f_ind = i

print(max_dist)
```
`Ответ:` 29


###### №3782
___
Текстовый файл [24-s1.txt](https://kpolyakov.spb.ru/cms/files/ege-sym/24-s1.txt) состоит не более чем из 106 символов и содержит только заглавные буквы латинского алфавита (ABC…Z). Текст разбит на строки различной длины. Необходимо найти строку, содержащую наибольшее количество букв Q (если таких строк несколько, надо взять ту, которая в файле встретилась позже). Определите, какая буква встречается в этой строке реже всего (но присутствует!). Если таких букв несколько, надо взять ту, которая стоит раньше в алфавите. Запишите в ответе эту букву, а затем – сколько раз она встречается во всем файле.  
Пример. Исходный файл:

ZZQAQB  
QAVQAB  
BAQTUB

В этом примере в первой и второй строках по две букву Q, в третьей – одна. Берём вторую строку, т.к. она стоит в файле позже. В этой строке реже других встречаются буквы V и B (по одному разу), выбираем букву B, т. к. она раньше стоит в алфавите. В ответе для этого примера надо записать B4, так как во всех строках файла буква B встречается 4 раза.
___

```python
file = open("24-s1.txt")

max_q_count = 0
min_s = ""
min_s_count = 0

for line in file.readlines():
    q_count = line.count("Q")

    if q_count > max_q_count:
        max_q_count = q_count
        min_s_count = 10**6

        for s in set(line):
            if s == "\n":
                continue
            s_count = line.count(s)
            if s_count < min_s_count or s_count == min_s_count and s < min_s:
                min_s = s
                min_s_count = s_count

file.close()  # Закрываем файл, чтобы чтобы
# Заново открываем файл, чтобы заново его прочитать
# и посчитать количество вхождений символа из ответа
file = open("24-s1.txt") 

count = file.read().count(min_s)

print(f"{min_s}{count}")
```


###### №4142
___
(А. Богданов) Текстовый файл [24-171.txt](https://kpolyakov.spb.ru/cms/files/ege-sym/24-171.txt) состоит не более чем из 106 символов и содержит только заглавные буквы латинского алфавита (ABC…Z). Файл разбит на строки различной длины. Определите максимальную длину цепочки символов, состоящей из повторяющихся фрагментов XYZ. Цепочка может начинаться и заканчиваться любым символом из XYZ, но внутри цепочки порядок строго определен. Например, для строки SAZXYZXYZXZQW длина цепочки равна 8: Z+XYZ+XYZ+X, где цепочка начинается с Z и заканчивается X.
___

Итак. Размышляем
	Цепочка символов `XYZ` не является самопересекающейся (см. №3348), значит можем её заменить на 1
	Так же не забываем проверять первый и последний символы!

```python
file = open("24-171.txt")

max_count = 0
count = 0

for line in file.readlines(): # Так как все в разных строчках
    max_count = max(max_count, count)
    count = 0
    # Не желательно изменять переменуую объявленную в `for`
    # поэтому создадим новую
    _line = line.replace("XYZ", "1")

    for s in _line:
        if s in "XYZ":  # Вместо сравнения с каждым символом по отдельности
            # Если этот символ стоит в конце, то проверяем длинну цепочки
            count += 1
            max_count = max(max_count, count)
            # И ставим `1`, потому что оно может быть 
            # началом новой цепочки символов
            count = 1
        elif s == "1":
            count += 3

        else:
            max_count = max(max_count, count)
            count = 0

print(max_count)
```

`Ответ:` 53


###### №4209
Задвача ==РЕШАЕМ ВНИМАТЕЛЬНО==
\![[Pasted image 20230210190248.png]]
___
(А. Богданов) Текстовый файл [24-171.txt](https://kpolyakov.spb.ru/cms/files/ege-sym/24-171.txt) состоит не более чем из 106 символов и содержит только заглавные буквы латинского алфавита (ABC…Z). Файл разбит на строки различной длины. Определите максимальную длину цепочки символов, состоящей из повторяющихся фрагментов XYZ. Цепочка может начинаться и заканчиваться любым символом из XYZ, но внутри цепочки порядок строго определен. Например, для строки SAZXYZXYZXZQW длина цепочки равна 8: Z+XYZ+XYZ+X, где цепочка начинается с Z и заканчивается X.
___

Размышляем?
	Опять же, `KEGE` - не сапоересекающаяся, значит - заменяем
		Хмм. Не более двух раз. Значит, когда мы встречаем `KEGE`, нам нужно сначала обработатать последовательность, которая включает эту `KEGE`, а потом обработать уже без нее
		Значит, попробуем запоминать, где мы встретили первую `KEGE`, и когда найдем третью - вернемся к первой и начнем считать без нее
		==НЕ ЗАБЫВАЕМ==, что, хоть `KEGE` не может входить больше трёх раз, но её части могут!
		тут ---> `EGEBCVAKEGEKASDAKEG` <---  и тут

Решаем!
```python
file = open("24-175.txt")
line = file.readline().replace("KEGE", "1")

kege_count = 0
ind = -1
max_count = 0
count = 0

# Используем цикл `while`, так как нам нужно возвращатся обратно
i = 0
while i < len(line):
    s = line[i]
    if s == "1":
        if ind == -1:
            ind = i
        if kege_count == 2:
	        # Потому что третья `KEGE` может входить как `KEG` в конце
            max_count = max(max_count, count + 3)
            kege_count = 0
            # Потому что первая `KEGE` может входить как `EGE` в начале
            count = 3
            i = ind
            ind = -1
        else:
            count += 4  # Так как в последовательности 4 символа
            kege_count += 1
    else:
        count += 1

    i += 1

max_count = max(max_count, count)
print(max_count)
```
`Ответ:` 946

###### №5936
___
(Е. Джобс) Текстовый файл [24-239.txt](https://kpolyakov.spb.ru/cms/files/ege-sym/24-239.txt) состоит не более чем из 106 символов и содержит только заглавные буквы латинского алфавита X, Y и Z. Найдите максимальную длину подстроки, которая состоит из сочетаний XY, YZ, YZZ, записанных в произвольном порядке. В ответе укажите наибольшую длину подходящей подстроки. Например, в строке ZZXZXZZXYYZYZZYYY самая длинная подходящая подстрока – XYYZYZZ имеет длину 7.
___

Потом решу:3
# Задача 26
Это задачи на применение навыков сортировки

Многие, а особенно простые задачи легко решаються в `Excel`, что мы с вами и попробуем. Также эти задачки могут (а иногда и будут только так) решаться с помощью программы
Каждая задача из этого блока будет (по возможности и желанию) разбираться как в `Excel`,  так и на `Python`

##### Задачки
ураураура

###### № 3766
___
(А. Кабанов) В текстовом файле записан набор натуральных чисел. Гарантируется, что все числа различны. Рассматриваются пары с чётной суммой, такие что:  
- хотя бы половина чисел набора меньше среднего арифметического пары  
- хотя бы четверть чисел набора больше среднего арифметического пары   
Определите количество таких пар и наименьшее из средних арифметических таких пар.  
**Входные данные** представлены в файле [26-50.txt](https://kpolyakov.spb.ru/cms/files/ege-sort/26-50.txt) следующим образом. Первая строка содержит целое число N – общее количество чисел в наборе. Каждая из следующих N строк содержит одно число, не превышающее 109.   
В ответе запишите два целых числа: сначала количество пар, затем наименьшее среднее арифметическое.  
**Пример входного файла**:  

8   
3   
8   
14   
11   
2   
16  
5  
9

В данном случае есть четыре подходящие пары: 2 и 16 (среднее арифметическое 9), 8 и 14 (среднее арифметическое 11), 9 и 11 (среднее арифметическое 10), 8 и 16 (среднее арифметическое 12). В ответе надо записать числа 4 и 9.
___

Думаем
  Для начала стоит заметить, что если мы возьмем четверть самых больших чисел, то проверять нам нужно будет только самое маденькое из них, потому что если ср.арифм
  превышает его, условию задачи мы уже не соответствуем

  Также и с половиной самых маленьких чисел. Если ср.арифм меньше самого большого из них, мы опять не удовлетворяем условию.

  Дальше мы отсортируем массив, что бы получить самые маленькие и большие числа

  И теперь, когда мы будем набирать пары чисел по возрастанию, стоит заметить, что если ср.арифм пары уже не удовлетворяет `второму` условию задачи, то нужно начать перебирать следущие пары 

```python
file = open("./26-50.txt")
n = int(file.readline())

# Читаем числа из файла и сразу сортируем
# (функция `sorted` возвращает список)
nums = sorted(map(int, file.readlines()))

# Находим самое большое число среди половины из самых маленьких
min_h = nums[n // 2 - 1]
# Находим самое маленькое число среди четверти из самых больших
max_h = nums[-(n // 4)]

count = 0
min_a = 10**9

# Теперь используем вложенные циклы
# чтобы перебрать все пары
for i in range(n - 1):
    for j in range(i + 1, n):
        n1 = nums[i]
        n2 = nums[j]


        if (n1 + n2) % 2: # Если сумма чисел пары нечетная
            continue

        sa = (n2 + n1) // 2 # Считаем среднее арифм.

		# Если не удовлетворяет второму условию из задачи
		# то нет сымслы идти дальше, так как дальше числа еще больше
        if sa >= max_h: 
            break

		# А если не удовлетворяем первому условию
		# то просто идем к чиселкам побольше
        if sa <= min_h:
            continue

        count += 1
        min_a = min(min_a, sa)

print(count, min_a)
```
`Ответ:` 2351097 54751679
###### № 5461
___
(М. Ишимов) Управляющей компании поступили жалобы об отсутствии капитального ремонта. В каждой жалобе указан номер дома и номер подъезда, где необходим ремонт. Компания решила в первую очередь сделать ремонт в тех домах, в которых есть подъезд без жалоб (чтобы расположить в нём строительные материалы) и не менее чем в 3 соседних подъездах жалобы присутствуют.  
Найдите общее количество жилых домов, которые планируется отремонтировать, и минимальный номер подъезда для размещения материалов, который находится в доме с максимальным номером.  
**Входные данные** представлены в файле [26-95.txt](https://kpolyakov.spb.ru/cms/files/ege-sort/26-95.txt) следующим образом. В первой строке входного файла записано натуральное число N, не превышающее 100000 – количество подъездов с жалобами. Каждая из следующих N строк содержит два натуральных числа: номер дома (не превышает 2000) и номер подъезда в доме (не превышает 5000).  
Запишите в ответе два числа: количество домов, где есть такие подходящие подъезды, и минимальный номер подъезда в подходящем доме с максимальным номером.  
**Пример входного файла:**:  

8  
1 5  
1 6  
1 7  
1 9  
2 1  
2 12  
1 10  
2 24  

При таких исходных данных есть два подходящих подъезда в 1-ом доме: № 4 (3 соседних подъезда с жалобами: 5, 6 и 7) и № 8 (4 соседних подъезда с жалобами: 6, 7, 9 и 10). Ответ: 1 4.
___

Итак, это уже одна из тех задач, что решается Excel'ем

1) Откроем текстовый файл в `Excel`
2) Выберем параметр `с разделителем`
3) Выберем знак табуляции и пробел
4) Готово!

Теперь перед нами excel файл