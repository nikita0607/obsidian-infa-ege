# Какие-нибудь подсказоньки
Если перебираешь пары, или тройки чисел, тогда вычитай из длинны списка на единицу меньше (то есть, если пара - вичитаем один, если тройка - два...)
```python
nums = [1, 2, 3, 4]

# Сумма пар чисел
for i in range(len(nums)-1):
	print(nums[i]+nums[i+1])
```
# Различные функции
##### Операторы в python
```python
a = 1
b = 2

a + b # =3 Сложение
a - b # =-1 Разность
a * b # =2 Умножение
a / b # =0.5 Деление
a // b # =0 Целочисленное деление
a % b # =1 Остаток от деления

# Оператроры, работающие с двоичными представлениями чисел
# Двоичные представления чисел
# a = 01
# b = 10

# Поразрядная конъюнкция (поразрядное умножение)
# 01 & 10 == 00
a & b # =0

# Поразрядная дизъюнкция (поразрядное `сложение`)
# 01 | 10 == 11
a | b # =3

# Поразрядное исключающее ИЛИ (xor)
# 01 ^ 10 == 11
# Больше примеров
# 01 ^ 01 == 00
# 10 ^ 01 == 11
# 101 ^ 011 == 110
a ^ b # =3

```
##### Булевы операторы
```python
a = True
b = False

a or b # =True Логическое ИЛИ (логическое сложение)
a and b # =False Логическое И (логическое умножение)
not a # =False Логическое НЕ (отрицание)

"""
Не забывайте тот факт, что `True` и `False` - это тоже числа
поэтому к ним применимы операторы, работающие с обычными числами

True - это `1`
False - это `0`

(в примерах ниже используется сумма и 
исключающее ИЛИ для булевых значений)
"""
```
##### Логические упрощения
Если необходимо, чтобы выполнялось только ОДНО условие из ДВУХ
```python
a = 10
b = 12
cond_1 = a < 12 # =True
cond_2 = b < 12 # =False

# Вспоминаем, что True и False - тоже числа
# и потому мы можем их складывать
if (cond_1 + cond_2) == 1:
	print("Это работает так!")

if cond_1 ^ cond_2:
	print("И так тоже!")
```

Если есть сразу несколько условий, которые соединяться `or` или `and`, то можно использовать встроенные в python функции  `any` и  `all`

```python
#eq (1 == 2) or (2 == 2) or (3 == 1)
any((1 == 2, 2 == 2, 3 == 1)) 

#eq (1 == 2) and (2 == 2) and (3 == 1)
all((1 == 2, 2 == 2, 3 == 1)) 
```



##### Другие встроенные функции
```python
abs(num)  # модуль числа

# Функция ко всем элементам списка
map(int, ["1", "2", "3"])

# Хотя бы одно истина
any([True, False, False]) #== True
# Все истины
all([True, False, False]) #== False
```

##### Встроенный перевод числа в систему счисления
```python
n = 10
bn = bin(a)[2:]  # Двоичная система
on = oct(a)[2:]  # Восьмиричная система
hn = hex(a)[2:]  # Шестнадцатиричная система

# Все эти функции возвращают строки
```

##### Перевод числа в любую систему
```python
def to_osn(num, osn):
	"""
	Имя функции может быть любым
	Вместо функции можно писать сразу в коде

	num: число в десятичной системе
	osn: основание новой системы
	
	"""

	# От сюда

	res = ""

	while num > 0:
		res = str(num%osn) + res
		num //= osn
	# И до сюда код можно вставить в программу без функции
	
	return res
```

Перевод числа в СС с основанием больше 10
```python
def to_osn(num, osn):
	res = ""
	alph = '0123456789ABCDEFGHIJKLMOPQRSTUVWXYZ'

	while num > 0:
		res = alph[num%osn] + res
		num //= osn

	return osn
```


##### Перевод числа из любой системы в десятичную
```python
bn = '1111'
on = '17'
hn = 'F'

n = int(bn, 2)
n = int(on, 8)
n = int(hn, 16)

# int(число; основание системы, из которой переводится)
# но это работает только с основаниями больше 1 и меньше 37
```


##### Определение четности числа
```python
n = 2

if n%2 == 0:
	print("Четное")
if n%2 != 0:  # Или n%2 == 1
	print("Нечетное")
```

##### Первые и последние цифры числа
```python
num = 123

# Срезы
if str(num)[-2:] == '23':
	print("Это работает")

# Остаток от деления
if num%100 == 23:
	print("Это тоже")
```
==Осторожно!!==
Для отрицательных чисел, при использовании остатка от деления необходимо брать модуль, иначе это не сработает!
```python
num = -123

if str(num)[-2:] == '23':
	print("Это работает!")

if num%100 == 23:
	print("А это нет!!")

# но
if abs(num%100) == 23:
	print("Работает!")
```
##### Сумма цифр числа
```python
n = 123
s = sum(map(int, str(n))) # 6

n = bin(2)[2:]  # 10
s = sum(map(int, n))  # Сумма цифр в двоичной записи
# Также является суммой всех единиц двоичного числа
```


##### Работа со строками и символами
```python
s = '12345'
print(ord(s[0])) # Номер символа `1` в таблице ASCII

#################

num = 10
s1 = "val:" + str(num)
s2 = f"val:{num}" # f-строки

if s1 == s2:
	print("Они одиноковы!")
	
##################

s = 'C'

if s == 'A' or s == 'B' or s == 'C':
	print("Это, конечно, работает...")
if s in 'ABC':
	print("Но это выглядит проще")

##################
```

##### Однострочники
Ввод чисел из файла в одну строку
```python
file = open('file.txt')
nums = list(map(int, file.readlines()))
```
Применение своей функции ко всем элементам списка
```python
def f(x):
	return x+1

nums = [1, 2, 3]
nums = list(map(f, nums))

# nums = [2, 3, 4]
```






##### Маска
```python
from fnmatch import *

num = 12345
fnmatch(str(num), "1*4?")
```

##### Перебор последовательностей
```python
from itertools import *

"""
product(list, repeat=1)
возвращает все возможные комбинации 
букв из алфавита `list` длинной `repeat`
"""
for i in product("КОП", repeat=2):
	print(i)
	# ('К', 'К')
	# ('К', 'О')
	# ('К', 'П')
	# ('O', 'O')
	# ...

"""
permutations(list, len)
возвращает все перестановки символов из
алфавита `list` длинной `len`
"""
for i in permutations("КОП", 2):
	print(i)
	# ('К', 'О')
	# ('К', 'П')
	# ('О', 'К')
```


# Задача 2
## Сопоставление логических таблиц
==Внимание!==
Не забываем расставлять приоритеты операций (если вы их не помните, приоритеты
расписаны в КИМе)

№3650
![[Pasted image 20230203102843.png]]

Решение этой задачи на языкe Python:

```python
print("a b c") # Перечислить все буквы из задачи

for a in (0, 1):
	for b in (0, 1):
		for c in (0, 1):  # Создаем цикл для каждый буквы
		# Если значение F в задаче равно 0, то все условие оборачивается в not()
			if (a == b) or (c == b):  
				print(a, b, c)
							
```
`Ответ`: cab
получается после анализа полученной таблицы и сравнения с исходной

# Задача 5
##  Moments
##### Условие на `минимальное R > КАКОГО-ТО ЧИСЛА`  
Если в конце условия задачи говориться, что нужно, например: `наименьше R, больше 34`,
а в самой задаче есть условия, из-за которых число может строиться по разным алгоритмам, например: 
`а) Если число четное, дописать ноль справа б) Если число нечетное, дописать еденицу слева`
не следует решать эту задачу в лоб, можно поступать следующим образом:
Перебирать n, до момента, когда все результаты работы программы буду превышать условие на R
Затем найти наименьшее число из вывода, удовлетворяющее условию >34
Затем наложить еще одно условие на R, при котором он должен быть <= полученого числа

Пример кода:
```python
def to_r(n):
	r = ...
	# Какой-то алгоритм преобразования в R
	return r

for n in range(1000):
	r = to_r(n)

	if r > 34:
		print(r, n)
```
Вывод программы:
```
37 29
39 30
40 31
44 32
36 33
48 34
49 35
51 36
35 37
...
...
...
еще много-много строк
```
В начале вывода мы видим `37`. Её и возьмем для доп. условия

Измененный код:
```python
for n in range(1000):
	r = to_r(n)

	if r > 34 and r <= 37: # Вот тут меняем
		print(r, n)
```

Новый вывод:
```
37 29
36 33
35 37
```

И тут мы выбираем самое маленькое `R`. А значит ответ:
`N=37`

## Основные функции
##### Перевод числа в систему счисления
```python
n = 10
bn = bin(a)[2:]  # Двоичная система
on = oct(a)[2:]  # Восьмиричная система
hn = hex(a)[2:]  # Шестнадцатиричная система

```

##### Сумма цифр числа
```python
n = 123
s = sum(map(int, str(n))) # 6

n = bin(2)[2:]  # 10
s = sum(map(int, n))  # Сумма цифр в двоичной записи
# Также является суммой всех единиц двоичного числа
```

## Автомат для работы с числами

Задачечка
№4444
![[Pasted image 20230203103232.png]]

Рассмотрим решение на `Python`

```python
# 1000 - это случайное число, после которого алгоритм вытаст число точно
# превосходящее 126

ans = []
for n in range(1, 1000):  
	r = bin(n)[2:] # В двоичную

	if n%2 == 1:  # Выполняем второй этап из задачи
		r = '1' + r + '0'
	else:
		r = '11' + r + '11'

	r = int(r, 2)  # В десятичную систему

	if r < 126:
		ans.append(r)

print(max(r))

```
`Ответ:` 123

Еще одна задача
№4808
![[Pasted image 20230203104850.png]]

Рассмотрим и эту задачу:
```python
for n in range(1, 10000000):  # Ответ ооочень больщой
    s1 = 0

    for d in str(n):  # Вычисляем сумму цифр из первого этапа
        if int(d) % 2 == 0:
            s1 += int(d)

    s2 = 0

    string = str(n)  # Избавимся от лишних дальнейших преобразований в строку
    for i in range(len(string)):
        if (i + 1) % 2 == 0:
            s2 += int(string[i])

    r = abs(s1 - s2)
    if r == 29:
        print(n)
        break
```
`Ответ:` 6080818
%5901
Рассмотрим задачу послежнее
![[Pasted image 20230204003615.png]]

```python

"""
Пояснение:

Мы начинаем с числа 8, потому что от нас требуют
брять ТРИ последних разряда, а первое число с КАК МИНИМУМ тремя разрядами - 
это 8

"""

ans = []
for n in range(8, 10000):
	bn = bin(n)[2:]
	_n = n-bn.count('0') #  Вычитаем количество нулей

	bn = bin(_n)[2:]  # Получаем новую двоичную запись числа

	bn = bn[-3:] + bn

	if int(bn, 2) > 224:
		ans.append(int(bn, 2))

print(min(ans))
```
`Ответ:` 227


## Автомат с битами чётности

Задача номер один
№7
![[Pasted image 20230204005306.png]]

```python
for n in range(1, 10000):
	bn = bin(n)[2:]

	s = sum(map(int, bn))
	bn += str(s%2)

	s = sum(map(int, bn))
	bn += str(s%2)

	r = int(bn, 2)

	if r > 125:
		print(n)
		break
```
`Ответ:` 31

Следущая задача
№3523
![[Pasted image 20230204005857.png]]

```python
'''


'''
ans = []
for n in range(1, 10000):
	_n = n*10 + n%10  # Дописываем в конец последнюю цифру
	bn = bin(_n)[2:]

	if sum(map(int, bn))%2 == 1:
		bn += '1'
	else:
		bn += '0'

	if int(bn, 2) > 413:
		ans.append(n)

print(min(ans))
```
`Ответ:` 21



## Автомат с инверсией битовой записи
Задача:
№1747
![[Pasted image 20230204010719.png]]

```python
for n in range(1, 256):
	bn = bin(n)[2:]

	# Чтобы число было восьмибитным, дописываем 
	# недостающие нули в начало числа
	bn = '0'*(8-len(bn)) + bn
	bn2 = ''

	repl = False
	for i in range(7, -1, -1):
		if repl:
			if bn[i] == '1':
				bn2 = '0' + bn2
			else:
				bn2 = '1' + bn2
		else:
			bn2 = bn[i] + bn2
			
		if bn[i] == '1':
			repl = True

	r = int(bn2, 2)

	if r == 98:
		print(n)
		break
```
`Ответ:` 128

Еще одна задача
№3525
![[Pasted image 20230204011739.png]]

```python
for n in range(1, 10000):
	dd = ""

	for i in str(n):
		bn = bin(int(i))[2:]
		bn = '0'*(4-len(bn)) + bn

		dd += bn

	bn = ''
	for i in dd:
		if i == '0':
			bn += '1'
		else:
			bn += '0'

	if int(bn, 2) == 151:
		print(n)
		break
```
`Ответ: 68

# Задача 6+
Для решения этой задачи используется модуль `turtle`
## Интересные вещи
##### +Программа для автоматического подсчета точек:
==Внимание==
КОД ИЗ ЗАДАЧИ должен быть строго замкунтой фигурой, иначе программа можеть давать неверный результат, т.е. нужно прекратить работу КОДА ИЗ ЗАДАЧИ как только исполнитель замкнет фигуру (то есть убрать лишние итерации цикла)
###### Пример: 
```python
from turtle import *

for i in range(10):
	forward(3)
	right(60)
#   |    Оптимизируем
#  \ /
for i in range(3):
	forward(3)
	right(60)
```
###### Код для подсчета точек:
```python
from turtle import *


color("black", "red") # Устанавливаем цвета
speed(1000)
 
m = 100  # Масштаб рисунка

begin_fill()
# КОД ИЗ ЗАДАЧИ
end_fill()

# Секретный магический код
canvas = getcanvas()
count = 0

for x in range(-100*m, 100*m, m):
	for y in range(-100*m, 100*m, m):
		item = canvas.find_overlaping(x, y, x, y)
		
		# item[0] == 5 проверяет,
		# с чем произошло пересечение
		if len(item) == 1 and item[0] == 5: # Проверяем, были ли пересечения
			count += 1

			### Для проверки можно расставить эти точки ###
			goto (x,y)
			dot(5,'blue')
			###############################################

print(count)
done()
```
##### Математические решения
Каноническое уравнение прямой*$$\frac{y-y_1}{y_2-y_1} = \frac{x-x_1}{x_2-x_1}$$
 

## Основные моменты

Если в задаче дан исполнитель `Чертежник`, командой перемещения которого является `сместиться`, то используется такой код для смещения:
```python
from turtle import *

m = 10 # Задаем масштаб

for i in range(2):
	goto(ycord(), xcord()-12*m) # сместиться на (0, -12)
	goto(ycord()+10*m, xcord()+12*m) # сместиться на (10, 12)
```

# Задача 14
## Основные функции
Перевод в любую систему счисления
Перевод из любой систеы счисления в десятичную
## Задачи

Задачечка один ==простенькая==
№5471
![[Pasted image 20230209232459.png]]
Решааем
```python
val = 7*(729**543) - 6*(81**765) - 5*(9**987) - 20
res = ''

while val > 0:
	res = str(val%9) + res
	val //= 9

print(res.count('8'))
```
`Ответ:` 1625

Следующая задача
№5483
![[Pasted image 20230209232929.png]]

Обращаем внимание, что нам нужен ==наименьший x==
Значит первый попавшийся подходящий x и будет ответом

Задача явно говорит, что  x - пятнидцатиричная цифра
славно, решаем!

```python
for x in range(15):
	# Переводим числа в десятичную систему счисления
	n1 = 5 + x*15 + 3*(15**2) + 2*(15**3) + 1*(15**4)
	n2 = 3 + 3*15 + 2*(15**2) + x*(15**3) + 1*(15**4)

	if (n1+n2)%14 == 0:
		print((n1+n2)//14)
		break  # Нашли, значит пора выйти из цикла
		
```
`Ответ:` 8767

Еще одна задачка ==НЕМНОГО ХАРДОВЕНЬКАЯ==
![[Pasted image 20230209234335.png]]

Итак, x - это цифра
Значит от 0 до 9 :3

Абсолютное значение - значит нужна функция `abs()`

```python
for x in range(10):
	osn = int('1' + str(x) + '324')
	
	n1 = 2*osn + 3  # Преобразуем число в дес. систему
	n2 = int('134' + str(x) + '2', 22)

	if abs(n1-n2)%50 == 31:
		print(abs(n1-n2)//50)
		# break отсутствует, потому что нам нужен максимальный x,
		# а значит, нужно идти до конца

		# хотя в этой задаче ответ выводится всего один
```

Немного упрощеный код с использованием f-строк
```python
for x in range(10):
	osn = int(f"1{x}324")
	
	n1 = 2*osn + 3  # Преобразуем число в дес. систему
	n2 = int(f"134{x}2", 22)

	if abs(n1-n2)%50 == 31:
		print(abs(n1-n2)//50)
		# break отсутствует, потому что нам нужен максимальный x,
		# а значит, нужно идти до конца

		# хотя в этой задаче ответ выводится всего один

```
`Ответ:` 4870

Задача
№4416
![[Pasted image 20230210105547.png]]
Сдандартное решение #1
```python
def to_osn(num, osn):
    res = ""
    alph = "0123456789ABCDEFGHIJKLMOPQRSTUVWXYZ"

    while num > 0:
        res = alph[num % osn] + res
        num //= osn

    return res


# Считаем число
val = 16**44 * 16**30 - (32**5 * (8**40 - 8**32) * (16**17 - 32**4))
# Заменяем `E` на 1
res = to_osn(val, 16).replace("E", "1")
# Удаляем 4 разряд из числа
res = res[:-5] + res[-4:]

print(res.count("1"))
```
Решение #2
```python
num = 16**44 * 16**30 - (32**5 * (8**40 - 8**32) * (16**17 - 32**4))
count = 0

r = 0

while num > 0:
	# Проверяем, что число цифра ИЛИ =1 ИЛИ  =`E`
	# а также пропускаем 4 разряд
    if (num % 16 == 1 or num % 16 == 14) and r != 4:
        count += 1
    num //= 16
    r += 1

print(count)
```
`Ответ:` 3

# Задача 17
## Основные функции
Чтение чисел из файла в одну строку
Сумма цифр числа
Выполнение только одного условия из двух
Цифры в начале и в конце

## Один проход

Задача
№4360
![[Pasted image 20230208225302.png]]

Что нам тут нужно?
Для начала, считываем числа (и так во всех таких задачах)

Пары элементов - значит не забываем отнять в цикле единицу от длинны списка
Хотя бы одна - значит можно и два - значит  ==or==
Максимальную из сумм (значит изначально переменная max_s = 0)

```python
file = open("17-8.txt")
nums = list(map(int, file.readlines()))

max_s = 0
count = 0

for i in range(len(nums)-1): # <- Отнимаем единицу
	bn1 = bin(nums[i])[2:]
	bn2 = bin(nums[i+1])[2:]

	s1 = sum(map(int, bn1))
	s2 = sum(map(int, bn2))

	if (s1 > 5 and s1%2 == 1) or (s2 > 5 and s2%2 == 1):
		count += 1
		max_s = max(max_s, nums[i]+nums[i+1])

print(count, max_s)
```
`Ответ:` 25 1773

Следующая задача
№4540
![[Pasted image 20230208230334.png]]
Сразу обращаем внимание, что числа могут быть ==отрицательными==
Это значит, что при операции остатка от деления нужно сначала взять модуль числа

Решим и её
```python
file = open("17-205.txt")
nums = list(map(int, file.readlines()))

count = 0
max_s = 0

for i in range(len(nums)-1):
	n1 = nums[i]
	n2 = nums[i+1]

	# Не забываем использовать модуль при остатке от деления
	# потому что у нас есть отрицательные числа
	
	if (abs(n1)%7 == 0) or (abs(n2)%7 == 0):
		if abs(n1+n2)%100 == 19:
			count += 1
			max_s = max(max_s, n1+n2)

print(count, max_s)
```
`Ответ:` 12 17219

Задача трив ==ХАРДВОВАЯ==
№5437
![[Pasted image 20230208231829.png]]

Решааем
```python
file = open('17-343.txt')
nums = list(map(int, file.readlines()))

count = 0
min_sum = 10**9

# Напишем функцию, которая обработает каждое число отдельно
def f(n):
	# Так как разряды нумеруются справа налево
	# развернем число, чтобы нумеровать слева направо
	sn = str(n)[::-1]

	s_chet = 0
	s_nechet = 0

	for i in range(1, len(sn), 2):
		s_nechet += int(sn[i])

	for i in rangr(0, len(sn), 2):
		s_chet += int(sn[i])

	return s_nechet%s_chet == 0

for i in range(len(nums)-2):
	if f(nums[i]) and f(nums[i+1]) and f(nums[i+1]):
		count += 1
		min_sum = min(min_sum, nums[i]+nums[i+1]+nums[i+2])

print(count, min_sum)
```
## Два+ прохода
Задача:
№5164
![[Pasted image 20230209182829.png]]

Два прохода означает, что сначала мы находим одно число, заданное условием задачи
И только затем начинаем искать пары чисел

Решим её:
```python
file = open("17-298.txt")
nums = list(map(int, file.readlines()))

max_num = 0

# С заданными условиями, и учитывая то, что мы ищем одно число,
# нам не нужно перебирать все индексы списка `nums`
for n in nums:
    if n % 197 == 0:
        max_num = max(max_num, n)

count = 0
max_sum = 0


# Будем проверять каждое число с помощью функции
def check(n):
    for d in str(n):  # `d` - от слова  digit
        if d == "0": # На ноль делить нельзя
            continue
        if n // int(d) == 197 and n % int(d) == 0:
            return True
    return False


for i in range(len(nums) - 1):
    n1 = nums[i]
    n2 = nums[i + 1]

	#  Не забываем, как написать: ЕСЛИ ВЫПОЛНЯЕТСЯ ТОЛЬКО ОДНО ИЗ ДВУХ
	#             \/-----вот тут
    if (check(n1) + check(n2)) == 1 and n1 + n2 < max_num:
        count += 1
        max_sum = max(max_sum, n1 + n2)

print(count, max_sum)
```
`Ответ:` 4341 9452

Следущая задача ==ХАРДОВАЯ==
№5260
![[Pasted image 20230209230117.png]]

Тройки чисел!
Как много условий, значит идем по порядку

```python
# Читаем числа
file = open("17-332.txt")
nums = list(map(int, file.readlines()))

# Начнем со среднего арифметического чисел, кратных 17

count = 0
s = 0

for n in nums:
    if n % 17 == 0:
        s += n
        count += 1

sr_arithm = s / count

# Обнулим `count`, чтобы потом записать в него ответ
count = 0
max_sum = 0
max_sum_count = 0

sums = []
set_sums = set() # Множество - добавляет значени только если его ещё нет

# Теперь примемся за перебор таких троек:
for i in range(len(nums) - 2):
    n1 = nums[i]
    n2 = nums[i + 1]
    n3 = nums[i + 2]

	# Считаем сумму цифр в числе
    s1 = sum(map(int, str(n1)))
    s2 = sum(map(int, str(n2)))
    s3 = sum(map(int, str(n3)))

    if s1 == s3 and n2 < sr_arithm:
        sums.append(s2) # Доюавляем очередную сумму в список
        set_sums.add(s2)  # И в множество
        count += 1

# А тут мы перебираем все наши суммы, которые храняться в единственном экземпляре
# и ищем ту, что встречается чаще
for n in set_sums:
    cur_sum_count = sums.count(n)
    if cur_sum_count > max_sum_count:
        max_sum_count = cur_sum_count
        max_sum = n

print(count, max_sum)
```
`Ответ:` 257 19
# Задача 18
Задачечка в excel! Юпиии

## Это база
Базовым для всех 18 задач является создание новой таблицы, в которой значения будут считаться динамически с помощью функций `МИН` и `МАКС`

Разберем простую задачу и маленькую табличку.

Пусть робот стоит в ==верхней левой== клетке таблицы. Он может двигаться только вправо и вниз. В каждой клетке лежат монеты, которые он забирает после посещения этой клетки. Какое максимальное количество монет может собрать робот?

Таблица0:

| 0 | A | B | C | D |
|---|---|---|---|---|
| 1 | ==24== | 12 | 100 | 29 |
| 2 | 19 | 10 | 15 | 10 |
| 3 | 32 | 15 | 20 | 7 |
| 4 | 12 | 23 | 18 | 6 |


А теперь напишем её решение
(`0` перед ссылкой на столбец означает, что значение береться из `Таблица0`)

| 0 | A | B | C | D |
|---|---|---|---|---|
| 1 | ==24== | =A1+0B1 | =B1+0С1 | =C1+0D1 |
| 2  | =A1+0А2 | =МИН(B1; A2)+0B2 <- растягиваем это формулу на все пустые ячейки| .. | .. |
| 3 | =A2+0A3 | .. | .. | .. |
| 4 | =A3+0A4 |..|..| .. (тут будет ответ, когда растянешь формулу) |

И мы получаем ответ в правой нижней клетке (куда шел робот)

Если нам нужно найти еще и максимум, то мы:
1) Выделяем нашу новую таблицу
2) Нажимаем заменить
3) Заменяем `МИН` на `МАКС`

##  Ямки
Для начала помечаем ямки в исходной таблице желтым цветом

Допустим, ямки - это отрицательные числа,  а робот начинает наверху слева:
Таб0
| 0 | A | B | C | D |
|---|---|---|---|---|
| 1 | 24 | ==-12== | 100 | 29 |
| 2 | 19 | 10 | 15 | 10 |
| 3 | ==-32== | 15 | ==-20== | 7 |
| 4 | 12 | 23 | 18 | 6 |

Тогда мы создаем новую таблицу как обычно, затем:
1) Копируем исходную таблицу с раскрашенными полями
2) Нажимаем на правый-верхний угол новой таблицы
3) Правая кнопка мыши - специальная вставка - вставить форматирование
4) Убираем все поля, которые раскрашенны цветом
| 0 | A | B | C | D |
|---|---|---|---|---|
| 1 | 24 |==--==| C1+0B1 | D1+0C1 |
| 2 | A1+0A2 | =МАКС(...) | =МАКС(...) | =МАКС(...) |
| 3 |==--==| =МАКС(...) |==--==| =МАКС(...) |
| 4 | A3+0A4 | =МАКС(...) | =МАКС(...) | =МАКС(...) |

Затем видим, что в клетки сверху, которые находятся справа от ямы, мы попасть больше не можем, значит их тоже надо удалить
| 0 | A | B | C | D |
|---|---|---|---|---|
| 1 | 24 |==--==| | |
| 2 | A1+0A2 | 10 | 15 | 10 |
| 3 |==--==| 15 |==--==| 7 |
| 4 | A3+0A4 | 23 | 18 | 6 |


А также клетки слева, которые под ямой
| 0 | A | B | C | D |
|---|---|---|---|---|
| 1 | 24 |==--==| | |
| 2 | A1+0A2 | =МАКС(...) | =МАКС(...) | =МАКС(...) |
| 3 |==--==| =МАКС(...) |==--==| =МАКС(...) |
| 4 | | =МАКС(...) | =МАКС(...) | =МАКС(...) (ответ)|


## Стенки как ямки
Решение ровно такое же, как и у ямок
## Стенки между клетками
#to-do
# Задача 19-21
Это задачи на теорию игр
##### Основные функции
```python
conds = [True, False, False]

# Применяет ИЛИ ко всем операндам из последовательности
any(conds) # == True

# Применяет И ко всем операндам из последовательности
all(conds) # == False
```

Основная функция для решения этих задач (две кучи)
```python
"""
Часть задачи:

Игра кончается, когда в кучах суммарно не менее 73 камней
Всего куч две

Своим ходом игрок может добавить один камень в кучу или увеличить количество камней в куче в два раза

В первой куче было 12 камней, а во второй S камней

Найдите такое наименьшее и натбольшее S, при котором Петя (первый игрок) 
победит ВТОРЫМ ХОДОМ при любом ходе Вани
"""


"""
Распишем ходы в игре

1 ход в игре совершает Петя
2 ход в игре - Вася
3 ход - Петя
4 - Вася...

То есть, второй ход Пети - это третий ход в игре
"""


# Задается условием задачи
# сколько камней должно быть в куче, чтобы игра закончилась
MAX_VAL = 73


def f(k1, k2, st, m):
	"""
	k1, k2 - кучи
	st - игровой ход
	m - ход, на котором ожидается конец игры
	"""

	# Если игрок победил
	if k1+k2 >= MAX_VAL:
		return st%2 == m%2 # Cовершил ли последний ход игрок, который нам нужен
	
	# Если сделано уже слишком много ходов
	if st == m:
		return 0
		
	st += 1
	# Просчитываем все возможные шаги
	moves = [f(k1+1, k2, st, m), f(k1*2, k2, st, m),
			 f(k1, k2+1, st, m), f(k1, k2*2, st, m)]

	# Если ход совершал игрок, который нам нужен
	if st%2 == m%2:
		return any(moves)
	return all(moves)


# Перебираем вторую кучку
for s in range(1, 61):
	# Перебираем кол-во максимальных ходов
	for m in range(1, 10):
		# Если игра закончилась первым ходом, то этот вариант нам не подходит
		if m == 1 and f(12, s, 0, m):
			break
		# А если третьим, то это наш ответ
		if m == 3 and f(12, s, 0, m):
			print(s)
```

Если в задаче сказанно, что соперник совершил `неудачный ход`,  то функция `all` меняется на `any`:

```python
def f(k1, k2, st, m):
	...
	if st%2 == m%2:
		return any(moves)
	return any(moves)
```


Если в задаче сказанно, что игрок может победить первым или вторым ходом, но не побеждает гарантированно первым, и требуется несколько ответов, то нужно проверить минимальные значения на предмет того, что в них игрок может победить первым ходом

Это можно сделать, поменяв ход соперника на неудачный и подставив числа из ответа.
И если в этих условиях он побеждает первым ходом, то ответ подходит.

Например, в задаче должен победить второй игрок и вывелся такой  ответ:
```shell
4
5
6
```

А нам нужны максимальный и минимальный
Тогда поменяем нашу функцию и проверим первый ответ

```python
def f(k1, k2, st, m):
	...
	return any(moves)

print(f(ЗНАЧЕНИЕ_ИЗ_ЗАДАЧИ, 4, 0, 2))
```
Вывод:
```python
False
```
Отсюда следует, что  `4` не пойдет в ответ


# Задача 24
## Основные функции
Получения номера сивола в таблице ASCII
## Поиск максимума и минимума
Задача
№3347
![[Pasted image 20230210110705.png]]

Решааем
```python
file = open("24-j2.txt")
line = file.readline()

count = 1
max_count = 0

for i in range(len(line)-1):
	if line[i] == line[i+1]:
		count += 1
	else:
		max_count = max(max_count, count)
		count = 1

print(max_count)
```
`Ответ:` 75

Следующая задача
№3348
![[Pasted image 20230210122849.png]]
Нам нужны комбинации символов
Заметим, что комбинация `КОТ` не является самопересекающейся, т.е., конец одной комбинации не может являтся началом другой:
	\\/--конец первой
КОТКОТ
	  ^-- начало второй
Решааем путем замены всех комбинаций `КОТ` на один символ, например 1

```python
file = open("24-j1.txt")
line = file.readline()

line = line.replace("КОТ", '1')

count = 1
max_count = 0
for i in range(len(line)-1):
	if line[i] == '1' and line[i] == line[i+1]:
		count += 1
	else:
		max_count = max(max_count, count)
		count = 1

print(max_count)
```
`Ответ:` 75


Некст таск ==немного СЛОЖНЕНЬКАЯ==
№3349
![[Pasted image 20230210124417.png]]

Решаем
```python
file = open("24-1.txt")
line = file.readline()

# Начинаем со второго символа т.к. первый не является локальным минимумом
f_ind = 0
max_dist = 0

for i in range(1, len(line)-1):
	# Получаем ascii номера символов
	a1 = ord(line[i-1])
	a2 = ord(line[i])
	a3 = ord(line[i+1])

	if a2 < a3 and a2 < a1:
		if f_ind == 0: # Если еще не находили локальных минимумов
			f_ind = i
		else:
			distance = i-f_ind
			max_dist = max(max_dist, distance)
			f_ind = i

print(max_dist)
```
`Ответ:` 29

Задачечка
№3782
![[Pasted image 20230210181238.png]]

```python
file = open("24-s1.txt")

max_q_count = 0
min_s = ""
min_s_count = 0

for line in file.readlines():
    q_count = line.count("Q")

    if q_count > max_q_count:
        max_q_count = q_count
        min_s_count = 10**6

        for s in set(line):
            if s == "\n":
                continue
            s_count = line.count(s)
            if s_count < min_s_count or s_count == min_s_count and s < min_s:
                min_s = s
                min_s_count = s_count

file.close()  # Закрываем файл, чтобы чтобы
# Заново открываем файл, чтобы заново его прочитать
# и посчитать количество вхождений символа из ответа
file = open("24-s1.txt") 

count = file.read().count(min_s)

print(f"{min_s}{count}")
```

ЗЗЗадачаа
№4142
![[Pasted image 20230210183930.png]]

Итак. Размышляем
	Цепочка символов `XYZ` не является самопересекающейся (см. №3348), значит можем её заменить на 1
	Так же не забываем проверять первый и последний символы!

```python
file = open("24-171.txt")

max_count = 0
count = 0

for line in file.readlines(): # Так как все в разных строчках
    max_count = max(max_count, count)
    count = 0
    # Не желательно изменять переменуую объявленную в `for`
    # поэтому создадим новую
    _line = line.replace("XYZ", "1")

    for s in _line:
        if s in "XYZ":  # Вместо сравнения с каждым символом по отдельности
            # Если этот символ стоит в конце, то проверяем длинну цепочки
            count += 1
            max_count = max(max_count, count)
            # И ставим `1`, потому что оно может быть 
            # началом новой цепочки символов
            count = 1
        elif s == "1":
            count += 3

        else:
            max_count = max(max_count, count)
            count = 0

print(max_count)
```

`Ответ:` 53

Задвача ==РЕШАЕМ ВНИМАТЕЛЬНО==
№4209
![[Pasted image 20230210190248.png]]

Размышляем?
	Опять же, `KEGE` - не сапоересекающаяся, значит - заменяем
		Хмм. Не более двух раз. Значит, когда мы встречаем `KEGE`, нам нужно сначала обработатать последовательность, которая включает эту `KEGE`, а потом обработать уже без нее
		Значит, попробуем запоминать, где мы встретили первую `KEGE`, и когда найдем третью - вернемся к первой и начнем считать без нее
		==НЕ ЗАБЫВАЕМ==, что, хоть `KEGE` не может входить больше трёх раз, но её части могут!
		тут ---> `EGEBCVAKEGEKASDAKEG` <---  и тут

Решаем!
```python
file = open("24-175.txt")
line = file.readline().replace("KEGE", "1")

kege_count = 0
ind = -1
max_count = 0
count = 0

# Используем цикл `while`, так как нам нужно возвращатся обратно
i = 0
while i < len(line):
    s = line[i]
    if s == "1":
        if ind == -1:
            ind = i
        if kege_count == 2:
	        # Потому что третья `KEGE` может входить как `KEG` в конце
            max_count = max(max_count, count + 3)
            kege_count = 0
            # Потому что первая `KEGE` может входить как `EGE` в начале
            count = 3
            i = ind
            ind = -1
        else:
            count += 4  # Так как в последовательности 4 символа
            kege_count += 1
    else:
        count += 1

    i += 1

max_count = max(max_count, count)
print(max_count)
```
`Ответ:` 946

Следущая таскочка
№5936
![[Pasted image 20230210211436.png]]